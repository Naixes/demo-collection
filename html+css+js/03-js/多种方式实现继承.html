<!DOCTYPE html>
<html>

<head>
	<title>多种方式实现继承</title>
</head>

<body>

</body>
<script type="text/javascript">
	// 父类
	// function Animal(color) {
	// 	this.color = color
	// }
	// // Animal.prototype.eat = function() {
	// // 	console.log('eating...')
	// // }
    // 如果要写成对象形式需要矫正constructor
	// Animal.prototype = {
    //     constructor: Animal,
    //     eat: () => {
    //         console.log('eating');
    //     }
    // }
	// // 或者手动重置构造器
	// Animal.prototype = {
    //     eat: () => {
    //         console.log('eating');
    //     }
    // }
	// Object.defineProperty(Animal.prototype, 'constructor', {
	// 	enumberable: false,
	// 	value: Animal
	// })

	// 原型实现继承
	// function Cat(name) {
	// 	this.name = name
	// }
	// Cat.prototype = new Animal('white')
	// const c1 = new Cat('c1')
	// console.log(c1.color)
	// c1.eat()
	// 缺点：不能向父类的构造函数传递参数
	// 引用类型的修改会被共享

	// 借用+原型继承
	// function Cat(color, name) {
	// 	Animal.call(this, color)
	// 	this.name = name
	// }
	// Cat.prototype = new Animal('white')
	// const c2 = new Cat('yellow', 'c2')
	// console.log(c2.color)
	// c2.eat()
	// 缺点：构造函数执行了两次

	// 寄生继承/混合继承
	// function Cat(color, name) {
	// 	Animal.call(this, color)
	// 	this.name = name
	// }
	// Cat.prototype = Object.create(Animal.prototype, {
	// 	constructor: {
	// 		value: Cat,
	// 		enumerable: false,
	// 		writable: true,
	// 		configurable: true
	// 	}
	// })
	// const c3 = new Cat('black', 'c3')
	// console.log(c3.color+'  '+c3.name)
	// c3.eat()

	// class实现继承，语法糖,本质还是函数，c小写
	class Animal {
		constructor(color) {
			this.color = color
		}
		eat() {
			console.log('eating..')
		}
	}
	class Cat extends Animal {
		constructor(color, name) {
			// super 在构造函数中，放在最开始
			super(color)
			// super不作为构造函数时，指向 this 而不是父类
			super.test = 1
			this.name = name
		}
	}
	const c4 = new Cat('white', 'c4')
	console.log(c4.color + '  ' + c4.name)
	c4.eat()
</script>

</html>