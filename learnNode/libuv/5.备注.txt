1 更新当前事件，在每次事件循环开始的时候，libuv会更新当前事件到变量中，
 这一轮循环的剩下操作可能使用这个变量获取当前事件，避免过多的系统调用影响性能。

2 如果时间循环是处于alive状态，则开始处理事件循环的每个阶段。
否则退出这个事件循环。alive状态是什么意思呢？如果有active和ref状态的handle，
active状态的request或者closing状态的handle则认为事件循环是alive的。

3 timer阶段：判断最小堆中的节点哪个节点超时了，执行他的回调。

4 pending阶段：执行pending回调。一般来说，
所有的io回调（网络，文件，dns）都会在poll io阶段执行。
但是有的情况下，poll io阶段的回调会延迟到下一次循环执行，
那么这种回调就是在pending阶段执行的。

5 idle阶段：如果节点处理avtive状态，每次事件循环都会被执行（idle不是说事件循环空闲的时候才执行）。
6 prepare阶段：和idle阶段一样。

7 poll io阶段：计算最长等待时间timeout，计算规则：
如果时间循环是以UV_RUN_NOWAIT模式运行的，则timeout是0。
如果时间循环即将退出（调用了uv_stop），则timeout是0。
如果没有active状态的handle或者request，timeout是0。
如果有idle阶段的队列里有节点，则timeout是0。
如果有handle等待被关闭的（即调了uv_close），timeout是0。
如果上面的都不满足，则取timer阶段中最快超时的节点作为timeout，如果没有则timeout等于-1，即永远阻塞，直到满足条件。
8 poll io阶段：调用各平台提供的io多路复用接口，最多等待timeout时间。返回的时候，执行对应的回调。（比如linux下就是epoll模式）

9 check阶段：和idle prepare一样。

10 closing阶段：处理调用了uv_close函数的handle的回调。

11 如果libuv是以UV_RUN_ONCE模式运行的，那事件循环即将退出。但是有一种情况是，poll io阶段的timeout的值是timer阶段的节点的值。并且poll io阶段是因为超时返回的，即没有任何事件发生，也没有执行任何io回调。这时候需要在执行一次timer阶段。因为有节点超时了。

12 一轮事件循环结束，如果libuv以UV_RUN_NOWAIT 或 UV_RUN_ONCE模式运行的，则退出事件循环。如果是以UV_RUN_DEFAULT模式运行的并且状态是alive，则开始下一轮循环。否则退出事件循环。


5. 【I/O poll阶段】 调用各平台提供的io多路复用接口，最多等待timeout时间,记录timeout 自己维护状态.在适当的条件下进行了阻塞。