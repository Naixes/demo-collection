<!DOCTYPE html>
<html>
<head>
	<title>多种方式实现继承</title>
</head>
<body>

</body>
<script type="text/javascript">
	// 原型实现继承
	// function Animal(color) {
	// 	this.color = color
	// }
	// Animal.prototype.eat = function() {
	// 	console.log('eating...')
	// }
	// function Cat(name) {
	// 	this.name = name
	// }
	// Cat.prototype = new Animal('white')
	// const c1 = new Cat('c1')
	// console.log(c1.color)
	// c1.eat()
	// 缺点：不能向父类的构造函数传递参数
	// 引用类型的修改会被共享

	// 借用+原型继承
	// function Cat(color, name) {
	// 	Animal.call(this, color)
	// 	this.name = name
	// }
	// Cat.prototype = new Animal('white')
	// const c2 = new Cat('yellow', 'c2')
	// console.log(c2.color)
	// c2.eat()
	// 缺点：构造函数执行了两次

	// 寄生继承
	// function Cat(color, name) {
	// 	Animal.call(this, color)
	// 	this.name = name
	// }
	// Cat.prototype = Object.create(Animal.prototype, {
	// 	constructor: {
	// 		value: Cat,
	// 		enumerable: false,
	// 		writable: true,
	// 		configurable: true
	// 	}
	// })
	// const c3 = new Cat('black', 'c3')
	// console.log(c3.color+'  '+c3.name)
	// c3.eat()

	// Class实现继承，c小写
	class Animal {
		constructor(color) {
			this.color = color
		}
		eat() {
			console.log('eating..')
		}
	}
	class Cat extends Animal {
		constructor(color, name) {
			// super 在构造函数中
			super(color)
			this.name = name
		}
	}
	const c4 = new Cat('white', 'c4')
	console.log(c4.color+'  '+c4.name)
	c4.eat()
</script>
</html>